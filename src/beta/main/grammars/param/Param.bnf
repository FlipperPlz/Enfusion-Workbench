{
    parserClass="com.flipperplz.enfusionWorkbench.languages.param.parser.ParamParser"
    extends="com.flipperplz.enfusionWorkbench.languages.param.psi.impl.ParamPsiElementImpl"
    implements="com.flipperplz.enfusionWorkbench.languages.param.psi.ParamPsiElement"

    psiClassPrefix="Param"
    psiImplClassSuffix="impl"
    psiPackage="com.flipperplz.enfusionWorkbench.languages.param.psi"
    psiImplPackage="com.flipperplz.enfusionWorkbench.languages.param.psi.impl"

    elementTypeHolderClass="com.flipperplz.enfusionWorkbench.languages.param.psi.ParamTypes"
    elementTypeClass="com.flipperplz.enfusionWorkbench.languages.param.psi.required.ParamElementType"
    tokenTypeClass="com.flipperplz.enfusionWorkbench.languages.param.psi.required.ParamTokenType"

    tokens = [
        SINGLE_LINE_COMMENT      = 'regexp://.*$';
        EMPTY_DELIMITED_COMMENT  = 'regexp:/\*\*?/';
        DELIMITED_COMMENT        = 'regexp:/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/'
        OP_ASSIGN                = '=';
        OP_ADDASSIGN             = '+=';
        OP_SUBASSIGN             = '-=';
        KW_CLASS                 = 'class';
        KW_DELETE                = 'delete';
        KW_ENUM                  = 'enum';
        KW_INCLUDE               = 'include';
        KW_DEFINE                = 'define';
        KW_UNDEF                 = 'undef';
        KW_IF                    = 'if';
        KW_IFDEF                 = 'ifdef';
        KW_IFNDEF                = 'ifndef';
        KW_ENDIF                 = 'endif';
        KW_ELSE                  = 'else';
        SYM_LCURLY               = '{';
        SYM_RCURLY               = '}';
        SYM_LSQUARE              = '[';
        SYM_RSQUARE              = ']';
        SYM_SEMI                 = ';';
        SYM_COLON                = ':';
        SYM_COMMA                = ',';
        SYM_LPARENTHESIS         = '(';
        SYM_RPARENTHESIS         = ')';
        SYM_BACKSLASH            = '\';
        SYM_DQUOTE               = '"';
        SYM_LANGLE               = "<";
        SYM_RANGLE               = '>';
        MACRO_LINE               = 'LINE';
        MACRO_FILE               = 'FILE';
        MACRO_EXEC               = 'EXEC'
        MACRO_EVAL               = 'EVAL';
        MACRO_MODE               = '__';
        DIRECTIVE_MODE           = '#';
        DIRECTIVE_CONCAT         = '##';
        REFERENCE_MODE           = '@';
        ABS_IDENTIFIER           = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*';
        ABS_STRING               = 'regexp:^"(?:[^"]|"")*"$';
        ABS_NUMERIC              = 'regexp:(-?[0-9]+(.[0-9]+)?([eE][-+]?[0-9]+)?|0x[a-fA-F0-9]+)';
        SPACE                    = 'regexp:\s+'
    ]
    generate=[tokenAccessors="yes"]

    extends("classDeclaration|variableDeclaration|comment|.*Statement")=statement
    extends("string|number|macroLiteral")=literal
    extends("literal|array")=arrayElement
    extends("fileMacro|lineMacro")=macro
    extends(".*Directive")=directive

    pin(".*Declaration|.*Directive|directive|.*Macro|classDeclaration|classExtension|macro|arraySquare|statementWithSemicolon|enumValue|.*Assignment")=1
    recoverWhile("directive|statementWithSemicolon|enumDeclaration")=statementRecover

    implements("classDeclaration|variableDeclaration|deleteStatement|identifier")="com.flipperplz.enfusionWorkbench.languages.param.psi.ParamNamedPsiElement"
    elementTypeFactory("classDeclaration|variableDeclaration|deleteStatement|identifier|macro|string|array|number|comment")="com.flipperplz.enfusionWorkbench.languages.param.psi.ParamElementFactoryKt.factory"

    mixin("classDeclaration")="com.flipperplz.enfusionWorkbench.languages.param.psi.mixins.impl.ParamClassDeclarationMixinImpl"
    mixin("variableDeclaration")="com.flipperplz.enfusionWorkbench.languages.param.psi.mixins.impl.ParamVariableDeclarationMixinImpl"
    mixin("deleteStatement")="com.flipperplz.enfusionWorkbench.languages.param.psi.mixins.impl.ParamDeleteStatementMixinImpl"
    mixin(".*Macro|macro|directive|abstractDefineValue|concatenateDirective|reference|includeString|.*Directive")="com.flipperplz.enfusionWorkbench.languages.param.psi.mixins.impl.ParamNonBinaraizableMixinImpl"
}

file ::= [statements] [enumDeclaration]

statement ::= (
     directive
   | classDeclaration
   | deleteStatement
   | variableDeclaration
   | comment
   | executeMacro
   | customMacro
)

literal ::= (
     string
   | number
   | macro
   | reference
)

arrayElement ::= (
     literal
   | array
)

comment ::= (
     SINGLE_LINE_COMMENT
   | delimitedComment
)

reference ::= REFERENCE_MODE identifier

macro ::= defaultMacro | customMacro

directive ::= DIRECTIVE_MODE directiveType { pin=2 }

classDeclaration ::= KW_CLASS commentWs identifier commentWs* [[classExtension] SYM_LCURLY commentWs* statementWithSemicolon* SYM_RCURLY]

enumDeclaration ::= KW_ENUM commentWs* SYM_LCURLY enumValueOrComment* SYM_RCURLY commentWs* SYM_SEMI commentWs* { pin=1 }

variableDeclaration ::= identifier commentWs* (arrayAssignment | valueAssignment) { pin=1 }

deleteStatement ::= KW_DELETE commentWs identifier  { pin=1 }

enumValue ::= identifier commentWs* [OP_ASSIGN commentWs* number] { pin=1 }

array ::= SYM_LCURLY commentWs* (arrayElement (commentWs* SYM_COMMA commentWs* (arrayElement | &(SYM_RCURLY | commentWs)))* commentWs*)? SYM_RCURLY commentWs SYM_SEMI { pin(".*")=1 }

number ::= ABS_NUMERIC

string ::= ABS_STRING

defineValue ::= (SYM_BACKSLASH EOL|literal|!EOL)

identifier ::= ABS_IDENTIFIER [concatenateDirective]

lineMacro ::= MACRO_LINE MACRO_MODE

fileMacro ::= MACRO_FILE MACRO_MODE

executeMacro ::= MACRO_EXEC sqfMacroTail

evaluateMacro ::= MACRO_EVAL sqfMacroTail

includeDirective ::= KW_INCLUDE commentWs* (string | includeString)

defineDirective ::= KW_DEFINE commentWs ABS_IDENTIFIER [argumentativeDefine] commentWs defineValue

concatenateDirective ::= DIRECTIVE_CONCAT identifier

undefineDirective ::= KW_UNDEF commentWs ABS_IDENTIFIER

ifDirective ::= ifDirectiveType commentWs ABS_IDENTIFIER EOL (
    statement*
) elseOrEndIfDirective

elseDirective ::= KW_ELSE commentWs* EOL

customMacro::= identifier [SYM_LPARENTHESIS [defineValue (SYM_COMMA defineValue)*] SYM_RPARENTHESIS]

private elseOrEndIfDirective ::= EOL DIRECTIVE_MODE (endIfDirective | elseDirective)

private ifDirectiveType ::= KW_IF | KW_IFDEF | KW_IFNDEF

private endIfDirective ::= KW_ENDIF commentWs* EOL

private argumentativeDefine ::= SYM_LPARENTHESIS [defineArguments] SYM_RPARENTHESIS

private defineArguments ::= ABS_IDENTIFIER (SYM_COMMA ABS_IDENTIFIER)*

private arrayAssignment ::= arraySquare delimitedComment* arrayOperator delimitedComment* array

private delimitedComment ::= (
     EMPTY_DELIMITED_COMMENT
   | DELIMITED_COMMENT
)

private directiveType ::=(
     includeDirective
   | defineDirective
   | undefineDirective
   | ifDirective
)

private sqfMacroTail ::= SYM_LPARENTHESIS (!(SYM_RPARENTHESIS))* SYM_RPARENTHESIS

private valueAssignment ::= normalOperator commentWs* literal { pin=1 }

private classExtension ::= SYM_COLON commentWs* identifier commentWs*

private statements ::= statementWithSemicolon+

private statementWithSemicolon ::= statement commentWs* SYM_SEMI commentWs* { pin=1 }

private includeString ::= SYM_LANGLE (!SYM_RANGLE)* SYM_RANGLE

private statementRecover ::= !(
     SYM_SEMI
   | SYM_COLON
   | SYM_LCURLY
   | SYM_LSQUARE
   | SYM_RCURLY
   | SYM_RSQUARE
   | ABS_IDENTIFIER
   | ABS_STRING
   | ABS_NUMERIC
   | KW_DELETE
   | KW_CLASS
   | SYM_COMMA
   | OP_ASSIGN
   | OP_ADDASSIGN
   | OP_SUBASSIGN
   | DIRECTIVE_MODE
   | DIRECTIVE_CONCAT
   | comment
   | directive
   | macro
   | statement
)

private enumValueOrComment ::= commentWs | enumValue

private normalOperator ::= OP_ASSIGN

private arrayOperator ::= normalOperator | OP_ADDASSIGN | OP_SUBASSIGN

private arraySquare ::= SYM_LSQUARE commentWs* SYM_RSQUARE

private commentWs ::= comment | SPACE

private defaultMacro ::= MACRO_MODE (
     lineMacro
   | fileMacro
   | evaluateMacro
)




