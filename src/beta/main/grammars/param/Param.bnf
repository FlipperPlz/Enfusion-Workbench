{
    parserClass="com.flipperplz.enfusionWorkbench.languages.param.parser.ParamParser"
    extends="com.flipperplz.enfusionWorkbench.languages.param.psi.impl.ParamPsiElementImpl"
    implements="com.flipperplz.enfusionWorkbench.languages.param.psi.ParamPsiElement"

    psiClassPrefix="Param"
    psiImplClassSuffix="Impl"
    psiPackage="com.flipperplz.enfusionWorkbench.languages.param.psi"
    psiImplPackage="com.flipperplz.enfusionWorkbench.languages.param.psi.impl"

    elementTypeHolderClass="com.flipperplz.enfusionWorkbench.languages.param.psi.ParamTypes"
    elementTypeClass="com.flipperplz.enfusionWorkbench.languages.param.psi.required.ParamElementType"
    tokenTypeClass="com.flipperplz.enfusionWorkbench.languages.param.psi.required.ParamTokenType"

    tokens = [
        SINGLE_LINE_COMMENT      = 'regexp://.*$';
        EMPTY_DELIMITED_COMMENT  = 'regexp:/\*\*?/';
        DELIMITED_COMMENT        = 'regexp:/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/'
        OP_ASSIGN                = '=';
        OP_ADDASSIGN             = '+=';
        OP_SUBASSIGN             = '-=';
        KW_CLASS                 = 'class';
        KW_DELETE                = 'delete';
        KW_ENUM                  = 'enum';
        KW_INCLUDE               = 'include';
        KW_DEFINE                = 'define';
        KW_UNDEF                 = 'undef';
        KW_IF                    = 'if';
        KW_IFDEF                 = 'ifdef';
        KW_IFNDEF                = 'ifndef';
        KW_ENDIF                 = 'endif';
        KW_ELSE                  = 'else';
        SYM_LCURLY               = '{';
        SYM_RCURLY               = '}';
        SYM_LSQUARE              = '[';
        SYM_RSQUARE              = ']';
        SYM_SEMI                 = ';';
        SYM_COLON                = ':';
        SYM_COMMA                = ',';
        SYM_LPARENTHESIS         = '(';
        SYM_RPARENTHESIS         = ')';
        SYM_DQUOTE               = '"';
        SYM_LANGLE               = "<";
        SYM_RANGLE               = '>';
        MACRO_LINE               = 'LINE';
        MACRO_FILE               = 'FILE';
        MACRO_EXEC               = 'EXEC'
        MACRO_EVAL               = 'EVAL';
        MACRO_MODE               = '__';
        DIRECTIVE_MODE           = '#';
        DIRECTIVE_CONCAT         = '##';
        REFERENCE_MODE           = '@';
        ABS_IDENTIFIER           = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*';
        ABS_STRING               = 'regexp:^"(?:[^"]|"")*"$';
        ABS_NUMERIC              = 'regexp:(-?[0-9]+(.[0-9]+)?([eE][-+]?[0-9]+)?|0x[a-fA-F0-9]+)';
        DIRECTIVE_NEWLINE        = 'regexp:\\(\r)?\n';
        WHITE_SPACE              = 'regexp:\s'
    ]
    generate=[tokenAccessors="yes"]

    extends("classDeclaration|directive|variableDeclaration|deleteStatement|executeMacro|customMacro")=statement
    extends("literal|array")=arrayElement
    extends("string|number|macro|reference")=literal
    extends("comment(Line|Delimited)")=comment

    implements("classDeclaration|variableDeclaration|deleteStatement|identifier")="com.flipperplz.enfusionWorkbench.languages.param.psi.ParamNamedPsiElement"

    mixin("classDeclaration")="com.flipperplz.enfusionWorkbench.languages.param.psi.mixins.impl.ParamClassDeclarationMixinImpl"
    mixin("variableDeclaration")="com.flipperplz.enfusionWorkbench.languages.param.psi.mixins.impl.ParamVariableDeclarationMixinImpl"
    mixin("deleteStatement")="com.flipperplz.enfusionWorkbench.languages.param.psi.mixins.impl.ParamDeleteStatementMixinImpl"
    mixin("identifier")="com.flipperplz.enfusionWorkbench.languages.param.psi.mixins.impl.ParamIdentifierMixinImpl"

    //Non Binarizables
    mixin("directive")="com.flipperplz.enfusionWorkbench.languages.param.psi.mixins.impl.ParamNonBinaraizableMixinImpl"
    mixin("executeMacro")="com.flipperplz.enfusionWorkbench.languages.param.psi.mixins.impl.ParamNonBinaraizableMixinImpl"
    mixin("macro")="com.flipperplz.enfusionWorkbench.languages.param.psi.mixins.impl.ParamNonBinaraizableMixinImpl"
    mixin("reference")="com.flipperplz.enfusionWorkbench.languages.param.psi.mixins.impl.ParamNonBinaraizableMixinImpl"
    mixin("concatenateDirective")="com.flipperplz.enfusionWorkbench.languages.param.psi.mixins.impl.ParamNonBinaraizableMixinImpl"

    //Error Correction
    pin("variableDeclaration|valueAssignment|(execute|default|evaluate|line|file)Macro")=1
    pin("(concatenate|include|(und|d)efine|if)Directive|enumValue|identifier|string")=1
    pin("reference|deleteStatement|directive|classDeclaration|classExtension|arraySquare")=1
    recoverWhile("directive|statementWithSemicolon|enumDeclaration")=statementRecover
}

file ::= [statements] [enumDeclaration]

statement ::= (
     directive
   | classDeclaration
   | deleteStatement
   | variableDeclaration
   | executeMacro
   | customMacro
)

literal ::= (
     string
   | number
   | macro
   | reference
)

arrayElement ::= (
     literal
   | array
)

comment ::= (
     commentLine
   | commentDelimited
)

reference ::= REFERENCE_MODE identifier

macro ::= defaultMacro | customMacro

directive ::= DIRECTIVE_MODE directiveType { pin=2 }

classDeclaration ::= KW_CLASS commentWs identifier commentWs* [[classExtension] SYM_LCURLY commentWs* statementWithSemicolon* SYM_RCURLY]

enumDeclaration ::= KW_ENUM commentWs* SYM_LCURLY enumValueOrComment* SYM_RCURLY commentWs* SYM_SEMI commentWs* { pin=1 }

variableDeclaration ::= identifier commentWs* (arrayAssignment | valueAssignment)

deleteStatement ::= KW_DELETE commentWs identifier

enumValue ::= identifier commentWs* [OP_ASSIGN commentWs* number]

array ::= SYM_LCURLY commentWs* (arrayElement (commentWs* SYM_COMMA commentWs* (arrayElement | &(SYM_RCURLY | commentWs)))* commentWs*)? SYM_RCURLY commentWs SYM_SEMI { pin(".*")=1 }

number ::= ABS_NUMERIC

string ::= STRING_START stringContent* STRING_END

identifier ::= ABS_IDENTIFIER [concatenateDirective]

lineMacro ::= MACRO_LINE EXIT_MACRO

fileMacro ::= MACRO_FILE EXIT_MACRO

executeMacro ::= MACRO_EXEC sqfMacroTail

evaluateMacro ::= MACRO_EVAL sqfMacroTail

includeDirective ::= KW_INCLUDE commentWs* (string | includeString)

defineDirective ::= KW_DEFINE commentWs ABS_IDENTIFIER [argumentativeDefine] (commentWs | SYM_HASH) DIRECTIVE_TAIL

concatenateDirective ::= CONCAT_MODE customMacro EXIT_CONCAT

undefineDirective ::= KW_UNDEF commentWs ABS_IDENTIFIER EXIT_DIRECTIVE

ifDirective ::= ifDirectiveType commentWs ABS_IDENTIFIER EXIT_DIRECTIVE (
    statement*
) elseOrEndIfDirective

commentLine ::= SINGLE_LINE_COMMENT

commentDelimited ::= (
     EMPTY_DELIMITED_COMMENT
   | DELIMITED_COMMENT
)

customMacro ::= ABS_IDENTIFIER [SYM_LPARENTHESIS [ABS_IDENTIFIER (SYM_COMMA ABS_IDENTIFIER)*] SYM_RPARENTHESIS]

private stringContent ::= STRING_CONTENT | LOCALIZED_STRING | STRING_ESCAPE;

private elseDirective ::= KW_ELSE commentWs* EXIT_DIRECTIVE

private elseOrEndIfDirective ::= DIRECTIVE_MODE (endIfDirective | elseDirective)

private ifDirectiveType ::= KW_IF | KW_IFDEF | KW_IFNDEF

private endIfDirective ::= KW_ENDIF commentWs* EXIT_DIRECTIVE

private argumentativeDefine ::= SYM_LPARENTHESIS [defineArguments] SYM_RPARENTHESIS

private defineArguments ::= ABS_IDENTIFIER (SYM_COMMA ABS_IDENTIFIER)*

private arrayAssignment ::= arraySquare commentDelimited* arrayOperator commentDelimited* array

private directiveType ::=(
     includeDirective
   | defineDirective
   | undefineDirective
   | ifDirective
)

private sqfMacroTail ::= SYM_LPARENTHESIS [SQF_STATEMENT] SYM_RPARENTHESIS

private valueAssignment ::= normalOperator commentWs* literal { pin=1 }

private classExtension ::= SYM_COLON commentWs* identifier commentWs*

private statements ::= statementWithSemicolon+

private statementWithSemicolon ::= statement commentWs* SYM_SEMI commentWs* { pin=1 }

private includeString ::= SYM_LANGLE (!SYM_RANGLE)* SYM_RANGLE

private statementRecover ::= !(
     SYM_SEMI
   | SYM_COLON
   | SYM_LCURLY
   | SYM_LSQUARE
   | SYM_RCURLY
   | SYM_RSQUARE
   | ABS_IDENTIFIER
   | ABS_STRING
   | ABS_NUMERIC
   | KW_DELETE
   | KW_CLASS
   | SYM_COMMA
   | OP_ASSIGN
   | OP_ADDASSIGN
   | OP_SUBASSIGN
   | DIRECTIVE_MODE
   | DIRECTIVE_CONCAT
   | comment
   | directive
   | macro
   | statement
)

private enumValueOrComment ::= commentWs | enumValue

private normalOperator ::= OP_ASSIGN

private arrayOperator ::= normalOperator | OP_ADDASSIGN | OP_SUBASSIGN

private arraySquare ::= SYM_LSQUARE commentWs* SYM_RSQUARE

private commentWs ::= comment | WHITE_SPACE

private defaultMacro ::= MACRO_MODE (
     lineMacro
   | fileMacro
   | evaluateMacro
)




